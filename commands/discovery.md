---
description: 执行需求发现阶段 - 理解需求、澄清问题、定义验收标准、识别风险
argument-hint: 功能需求描述
---

# /discovery - 需求发现阶段

执行端到端交付流程的第一阶段：需求发现。

## 使用方式

```bash
# 启动需求发现阶段
/discovery "实现用户登录功能"

# 从现有描述继续
/discovery --resume
```

## 阶段目标

将模糊的想法转化为清晰、可执行的需求规格。

## 工作流程

### 1. 需求理解（v2.0 增强流程）

#### 1.1 需求分析
```markdown
## 需求分析

**输入**: $ARGUMENTS

**理解摘要**:
- 功能目标: [一句话描述]
- 目标用户: [谁使用]
- 使用场景: [在什么情况下使用]
- 核心价值: [带来什么价值]
```

#### 1.2 复杂度评估（v2.0 新增）

使用 `utils/complexity-evaluator.md` 评估需求复杂度：

```markdown
## 需求复杂度评估

### 评估维度

| 维度 | 评分 | 说明 |
|------|------|------|
| 功能复杂度 | 1-10 | 功能数量、业务逻辑复杂度 |
| 技术复杂度 | 1-10 | 技术难度、集成复杂度 |
| 规模复杂度 | 1-10 | 代码规模、团队规模 |
| 风险复杂度 | 1-10 | 技术风险、业务风险 |

### 计算公式
总分 = (功能复杂度 × 1.0) + (技术复杂度 × 1.2) + (规模复杂度 × 1.0) + (风险复杂度 × 1.5)

### 复杂度分级
- **高复杂度** (≥12分): 瀑布流模式 → 用户需求规格说明书 + 系统需求规格说明书
- **中复杂度** (8-11分): 敏捷模式 → Epic → Feature → Story
- **低复杂度** (0-7分): 敏捷模式 → Epic → Feature → Story
```

#### 1.3 模板选择（v2.0 新增）

根据复杂度自动选择对应的模板：

```markdown
## 模板选择

**复杂度等级**: [高/中/低]
**开发模式**: [瀑布流/敏捷]
**需求模板**: [具体模板名称]
```

### 2. Brainstorming
进行创意发散，探索多种可能性:
- SCAMPER 方法
- 五个为什么
- 类比思考

### 3. 澄清问题
提出针对性的澄清问题:
- 功能维度: 具体功能、输入输出、边界条件
- 用户维度: 目标用户、使用场景、用户痛点
- 技术维度: 技术约束、兼容性、性能要求
- 质量维度: 可靠性、安全性、可维护性

### 4. 验收标准定义
定义清晰可测试的验收标准:
- AC-001: [可测试的条件]
- AC-002: [可测试的条件]

### 5. 风险识别
识别潜在风险和缓解措施:
- 技术风险
- 时间风险
- 资源风险
- 依赖风险

## 阶段输出

```markdown
# [Feature Name] 需求规格

## 背景
- 问题陈述: [描述]
- 业务价值: [价值]
- 目标用户: [用户]

## 功能需求
### 核心功能
- FR-001: [功能描述]
- FR-002: [功能描述]

### 验收标准
- AC-001: Given [前提] When [操作] Then [预期]
- AC-002: Given [前提] When [操作] Then [预期]

## 非功能需求
- 性能: [具体指标]
- 安全: [安全要求]
- 兼容性: [兼容范围]

## 约束与假设
- 技术约束: [约束]
- 时间约束: [约束]
- 资源约束: [约束]
- 假设条件: [假设]

## 风险识别
- 风险1: [描述] - 缓解: [措施]
- 风险2: [描述] - 缓解: [措施]
```

## 质量门禁

完成需求发现前，确认:
- [ ] 需求清晰明确，无歧义
- [ ] 验收标准可测试
- [ ] 约束条件已识别
- [ ] 风险已评估
- [ ] 用户已确认

## 下一阶段

需求发现完成后，进入代码库探索阶段:
```bash
/exploration
```
