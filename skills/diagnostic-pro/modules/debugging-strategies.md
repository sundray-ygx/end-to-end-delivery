# Debugging Strategies 模块

系统化调试技术框架，提供科学的诊断方法论。

## 核心原则

### 1. 科学方法
1. **观察**: 实际行为是什么？
2. **假设**: 可能的原因是什么？
3. **实验**: 测试假设
4. **分析**: 证明/反驳理论
5. **重复**: 直到找到根本原因

### 2. 调试心态

**不要假设**:
- "不可能是 X" - 是的，可能
- "我没改 Y" - 无论如何检查
- "在我机器上能跑" - 找出原因

**要做的**:
- 一致地复现
- 隔离问题
- 记录详细笔记
- 质疑一切
- 卡住时休息

### 3. Rubber Duck 调试法

向橡皮鸭、同事或自己大声解释代码和问题。通常能揭示问题。

## 系统化调试流程

### Phase 1: 复现

**复现检查清单**:
1. **能复现吗？**
   - 总是？有时？随机？
   - 需要特定条件？
   - 其他人能复现吗？

2. **创建最小复现**
   - 简化到最小示例
   - 移除无关代码
   - 隔离问题

3. **记录步骤**
   - 写下确切步骤
   - 记录环境细节
   - 捕获错误消息

### Phase 2: 收集信息

**信息收集**:
1. **错误消息**
   - 完整堆栈跟踪
   - 错误代码
   - 控制台/日志输出

2. **环境**
   - 操作系统版本
   - 语言/运行时版本
   - 依赖版本
   - 环境变量

3. **最近变更**
   - Git 历史
   - 部署时间线
   - 配置变更

4. **范围**
   - 影响所有用户还是特定用户？
   - 所有浏览器还是特定浏览器？
   - 仅生产环境还是开发环境也有？

### Phase 3: 形成假设

**假设形成**:
基于收集的信息，询问：

1. **什么改变了？**
   - 最近的代码变更
   - 依赖更新
   - 基础设施变更

2. **有什么不同？**
   - 工作环境 vs 破坏环境
   - 工作用户 vs 破坏用户
   - 之前 vs 之后

3. **哪里可能失败？**
   - 输入验证
   - 业务逻辑
   - 数据层
   - 外部服务

### Phase 4: 测试与验证

**测试策略**:
1. **二分搜索**
   - 注释掉一半代码
   - 缩小问题区域
   - 重复直到找到

2. **添加日志**
   - 战略性 console.log/print
   - 跟踪变量值
   - 追踪执行流程

3. **隔离组件**
   - 分别测试每个部分
   - 模拟依赖
   - 移除复杂性

4. **对比工作 vs 破坏**
   - 对比配置
   - 对比环境
   - 对比数据

## 高级调试技术

### 技术 1: 二分搜索调试

```bash
# 使用 git bisect 查找回归
git bisect start
git bisect bad                    # 当前提交是坏的
git bisect good v1.0.0            # v1.0.0 是好的

# Git 检出中间提交
# 测试，然后：
git bisect good   # 如果工作
git bisect bad    # 如果破坏

# 继续直到找到 bug
git bisect reset  # 完成后重置
```

### 技术 2: 差分调试

对比工作 vs 破坏：

| 方面 | 工作 | 破坏 |
|------|------|------|
| 环境 | 开发 | 生产 |
| Node 版本 | 18.16.0 | 18.15.0 |
| 数据 | 空 DB | 100万记录 |
| 用户 | 管理员 | 普通用户 |
| 浏览器 | Chrome | Safari |
| 时间 | 白天 | 午夜 |

**假设**: 时间相关问题？检查时区处理。

### 技术 3: 追踪调试

```typescript
// 函数调用追踪
function trace(
  target: any,
  propertyKey: string,
  descriptor: PropertyDescriptor,
) {
  const originalMethod = descriptor.value;

  descriptor.value = function (...args: any[]) {
    console.log(`Calling ${propertyKey} with args:`, args);
    const result = originalMethod.apply(this, args);
    console.log(`${propertyKey} returned:`, result);
    return result;
  };

  return descriptor;
}
```

### 技术 4: 内存泄漏检测

```typescript
// Chrome DevTools 内存分析器
// 1. 获取堆快照
// 2. 执行操作
// 3. 获取另一个快照
// 4. 对比快照

// Node.js 内存调试
if (process.memoryUsage().heapUsed > 500 * 1024 * 1024) {
  console.warn("High memory usage:", process.memoryUsage());
  require("v8").writeHeapSnapshot();
}
```

## 按问题类型分类的调试模式

### 模式 1: 间歇性 Bug

**策略**:
1. **添加大量日志**
   - 记录时序信息
   - 记录所有状态转换
   - 记录外部交互

2. **查找竞态条件**
   - 对共享状态的并发访问
   - 异步操作乱序完成
   - 缺少同步

3. **检查时序依赖**
   - setTimeout/setInterval
   - Promise 解析顺序
   - 动画帧时序

4. **压力测试**
   - 多次运行
   - 变化时序
   - 模拟负载

### 模式 2: 性能问题

**策略**:
1. **首先分析**
   - 不要盲目优化
   - 优化前后测量
   - 找到瓶颈

2. **常见罪魁祸首**
   - N+1 查询
   - 不必要的重渲染
   - 大数据处理
   - 同步 I/O

3. **工具**
   - 浏览器 DevTools 性能选项卡
   - Lighthouse
   - Python: cProfile, line_profiler
   - Node: clinic.js, 0x

### 模式 3: 生产 Bug

**策略**:
1. **收集证据**
   - 错误追踪 (Sentry, Bugsnag)
   - 应用日志
   - 用户报告
   - 指标/监控

2. **本地复现**
   - 使用生产数据（匿名化）
   - 匹配环境
   - 遵循确切步骤

3. **安全调查**
   - 不要改变生产
   - 使用功能标志
   - 添加监控/日志
   - 在暂存环境测试修复

## 快速调试检查清单

**卡住时，检查**:
- [ ] 拼写错误（变量名拼写错误）
- [ ] 大小写敏感（fileName vs filename）
- [ ] Null/undefined 值
- [ ] 数组索引越界
- [ ] 异步时序（竞态条件）
- [ ] 作用域问题（闭包、提升）
- [ ] 类型不匹配
- [ ] 缺少依赖
- [ ] 环境变量
- [ ] 文件路径（绝对 vs 相对）
- [ ] 缓存问题（清除缓存）
- [ ] 陈旧数据（刷新数据库）
