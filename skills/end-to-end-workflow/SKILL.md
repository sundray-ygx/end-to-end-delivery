---
name: end-to-end-workflow
description: 端到端价值交付闭环工作流 - 整合需求发现、代码库探索、架构设计、实施执行、质量验证、价值交付的完整流程。v3.0 新增：diagnostic-pro 诊断系统、continuous-learning-v2 Instinct 学习、Python/Go/C/C++ 多语言支持、eval-harness 评估驱动、database-reviewer 数据库专家
---

# 端到端价值交付闭环工作流

## 概述

本技能整合了 superpowers、everything-claude-code、feature-dev 三大插件的精华，形成完整的端到端价值交付闭环。

**v3.0 新增能力**:
- **diagnostic-pro**: 整合三大插件优势的调试、诊断、修复系统
- **continuous-learning-v2**: Instinct-based 学习系统，自动提取和演化知识
- **多语言支持**: Python、Go、C/C++ 全栈开发模式
- **eval-harness**: 评估驱动开发（EDD），在需求阶段定义评估标准
- **database-reviewer**: PostgreSQL 数据库专家，优化查询性能
- **iterative-retrieval**: 解决子代理上下文问题的渐进式检索模式

**核心原则**: Evidence Before Claims, Quality First, Continuous Learning

## 工作流架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        端到端价值交付闭环工作流                              │
└─────────────────────────────────────────────────────────────────────────────┘

     ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
     │  Discovery  │───▶│ Exploration │───▶│    Design   │
     │  需求发现    │    │  代码库探索  │    │   架构设计   │
     └─────────────┘    └─────────────┘    └─────────────┘
           │                   │                   │
           ▼                   ▼                   ▼
     ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
     │ 澄清问题    │    │ 映射架构    │    │ 多方案对比  │
     │ Brainstorm │    │ 识别模式    │    │ 权衡分析    │
     │ 需求规格化  │    │ 关键文件    │    │ 实施蓝图    │
     └─────────────┘    └─────────────┘    └─────────────┘
                                                     │
                                                     ▼
     ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
     │   Summary   │◀───│Verification │◀───│Implementation│
     │  交付总结    │    │   质量验证   │    │   实施执行   │
     └─────────────┘    └─────────────┘    └─────────────┘
           │                   │                   │
           ▼                   ▼                   ▼
     ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
     │ 价值验证    │    │ 全面验证    │    │ TDD 执行    │
     │ 模式提取    │    │ 证据优先    │    │ 两阶段审查  │
     │ 知识沉淀    │    │ 质量门禁    │    │ 自审修复    │
     └─────────────┘    └─────────────┘    └─────────────┘
           │
           ▼
     ┌─────────────┐
     │  闭环反馈   │
     │ Continuous  │
     │  Learning   │
     └─────────────┘
```

## 阶段详解

### 阶段 1: Discovery (需求发现) - v2.0 增强

**目标**: 将模糊想法转化为清晰需求

**输入**: 用户需求描述
**输出**: 结构化需求规格

**活动**:
1. 需求理解与澄清
2. Brainstorming 创意发散
3. 验收标准定义
4. 风险识别

**v2.0 新增能力**:
- 自动评估需求复杂度（功能、技术、规模、风险四个维度）
- 根据复杂度选择开发模式：
  - 高复杂度 (≥12) → 瀑布流模式
  - 中/低复杂度 (<12) → 敏捷模式
- 基于模板维度进行深度需求分析

**使用的代理**: `discovery-agent`

**使用场景**:
```bash
# 启动端到端流程（自动评估复杂度并选择模式）
/deliver "实现用户登录功能"

# 或从需求发现阶段开始
/discovery "用户需要能够使用邮箱和密码登录"
```

**执行流程**:
1. 智能需求分析（discovery-agent）
2. 复杂度评估（utils/complexity-evaluator.md）
3. 模板选择（utils/template-adapter.md）
4. 基于模板维度进行深度需求分析

**产出物**:
- 基于维度的深度需求分析报告
- 验收标准清单
- 风险评估
- 复杂度评估报告

---

### 阶段 2: Exploration (代码库探索)

**目标**: 快速理解代码库上下文

**输入**: 需求规格
**输出**: 代码库分析报告

**活动**:
1. 项目结构映射
2. 现有模式识别
3. 相关功能分析
4. 关键文件标注

**使用的代理**: `exploration-agent`

**产出物**:
- 代码库地图
- 模式清单
- 必读文件列表
- 技术债务报告

---

### 阶段 3: Design (架构设计) - v2.0 增强

**目标**: 提供高质量的架构方案

**输入**: 需求规格 + 代码库分析
**输出**: 架构设计方案

**活动**:
1. 生成 3 个架构方案
2. 权衡分析
3. 推荐方案
4. 实施蓝图

**v2.0 新增能力**:
- 根据需求复杂度选择设计分析框架：
  - 高复杂度 (≥12) → 总体设计 + 模块拆分
  - 中复杂度 (8-11) → 模块详细设计
  - 低复杂度 (0-7) → 模块微型设计
- 基于模板维度进行深度架构设计分析

**使用的代理**: `design-agent`

**方案类型**:
- **方案 A**: 最小变更 (快速实施)
- **方案 B**: 清晰架构 (长期维护)
- **方案 C**: 务实平衡 (大多数场景)

**产出物**:
- 架构设计方案
- 权衡分析报告
- 实施蓝图
- 组件接口定义
- 基于维度的深度架构设计分析报告

---

### 阶段 4: Implementation (实施执行) - v2.0 增强

**目标**: 高质量实现功能

**输入**: 实施蓝图
**输出**: 可工作的代码

**活动**:
1. TDD 红绿重构循环
2. 两阶段审查 (规格 → 质量)
3. 自审与修复
4. 频繁提交

**v2.0 新增能力**:
- 自动检测项目编程语言
- 加载对应的编码 checklist，提取审查维度：
  - Python → coding-checklist-python.md
  - Go → coding-checklist-go.md
  - JavaScript/TypeScript → coding-checklist-js.md
  - 其他语言...
- 基于checklist维度进行深度代码审查
- 生成编码规范审查报告

**使用的代理**: `implementation-agent`

**TDD 流程**:
```
RED   → 编写失败的测试
GREEN → 实现最小代码
REFACTOR → 重构改进
```

**审查流程**:
```
实施 → 自审 → 规格审查 → 修复 → 质量审查 → 修复 → 完成
```

**产出物**:
- 实现的代码（符合编码规范）
- 测试代码
- 提交历史
- 基于checklist维度的深度代码审查报告

---

### 阶段 5: Verification (质量验证) - v2.0 增强

**目标**: 确保质量标准

**输入**: 实施的代码
**输出**: 验证报告

**活动**:
1. 构建验证
2. 类型检查
3. 代码规范检查
4. 测试验证
5. 安全扫描

**v2.0 新增能力**:
- 验证需求分析维度覆盖度
- 验证设计分析维度覆盖度
- 验证编码审查维度覆盖度
- 生成维度覆盖度验证报告

**使用的代理**: `verification-agent`

**验证项**:
```bash
# 构建验证
npm run build

# 类型检查
npx tsc --noEmit

# 代码规范
npm run lint

# 测试验证
npm test -- --coverage

# 安全扫描
grep -rn "sk-" --include="*.ts" . | head -10
```

**产出物**:
- 验证报告
- 问题清单
- 修复建议
- 维度覆盖度验证报告

---

### 阶段 6: Delivery (价值交付) - v2.0 增强

**目标**: 完成交付并沉淀知识

**输入**: 验证通过的代码
**输出**: 交付物和学习记录

**活动**:
1. 交付就绪检查
2. 文档生成
3. 价值验证
4. 模式提取

**v2.0 新增能力**:
- 基于各阶段维度分析成果生成交付总结
- 生成端到端价值交付总结报告
- 提取符合企业标准的价值模式
- 支持多种交付文档类型

**使用的代理**: `delivery-agent`

**交付物**:
- 变更日志
- 发布说明
- 技术文档
- PR 描述
- 端到端价值交付总结报告

**学习记录**:
- 新发现的模式
- 最佳实践
- 经验教训
- 可复用组件

---

## 核心原则

### 1. Evidence Before Claims (证据优先)
```markdown
❌ 错误: "应该能工作"
✅ 正确: "测试全部通过 (34/34), 覆盖率 95%"

❌ 错误: "看起来没问题"
✅ 正确: "构建成功, 类型检查通过, lint 无错误"

**铁律**: NO COMPLETION CLAIMS WITHOUT FRESH VERIFICATION EVIDENCE
```

### 2. Quality First (质量第一)
- 测试覆盖率 ≥ 80%
- 所有测试通过
- 代码规范通过
- 安全扫描通过

### 3. Continuous Learning (持续学习)
- 每次交付提取新模式
- 更新技能库
- 记录最佳实践
- 促进知识共享

### 4. YAGNI (You Aren't Gonna Need It)
- 只实现需要的功能
- 避免过度设计
- 保持简单

### 5. DRY (Don't Repeat Yourself)
- 提取可复用模式
- 创建共享组件
- 避免重复代码

---

## 命令体系

### 主要命令

#### `/deliver` - 端到端交付
```bash
/deliver "实现用户登录功能"
```
启动完整的端到端交付流程

#### `/discovery` - 需求发现
```bash
/discovery "用户需要登录功能"
```
进入需求发现阶段

#### `/exploration` - 代码库探索
```bash
/exploration
```
进入代码库探索阶段 (需先完成 discovery)

#### `/design` - 架构设计
```bash
/design
```
进入架构设计阶段 (需先完成 discovery 和 exploration)

#### `/implement` - 实施执行
```bash
/implement
```
进入实施执行阶段 (需先完成 design)

#### `/verify` - 质量验证
```bash
/verify
```
进入质量验证阶段

#### `/delivery` - 价值交付
```bash
/delivery
```
进入价值交付阶段

---

## 与子代理的协作

### 并行探索
```markdown
当需要快速理解代码库时，可以并行启动多个探索代理:

[并行启动]
1. code-explorer (探索类似功能)
2. code-explorer (探索架构模式)
3. code-explorer (探索测试模式)

[汇总结果]
综合分析所有代理的发现，形成完整的代码库理解
```

### 并行设计
```markdown
架构设计阶段，可以并行生成多个方案:

[并行启动]
1. design-agent (最小变更方案)
2. design-agent (清晰架构方案)
3. design-agent (务实平衡方案)

[汇总选择]
分析所有方案，推荐最合适的方案
```

### 并行审查
```markdown
实施完成后，可以并行进行多种审查:

[并行启动]
1. code-reviewer (简洁性/DRY/优雅)
2. code-reviewer (Bug/功能正确性)
3. code-reviewer (项目规范/抽象)
4. security-reviewer (安全漏洞)

[汇总修复]
综合所有审查意见，修复问题
```

---

## 模板系统

### 本地模板融合

插件支持融合本地的开发流程模板，并提供智能回退机制：

```bash
# 模板位置
templates/custom-workflow/

# 模板类型
- project-structure/     # 项目结构模板
- documentation/         # 文档模板
- coding-standards/      # 代码规范模板
- testing-patterns/      # 测试模式模板
```

### 模板查找顺序（自动回退）

**重要**: 当本地没有配置模板时，插件会自动使用内置的默认模板。

```
1. 项目根目录/.claude/templates/{templatePath}  (用户自定义 - 最高优先级)
2. 项目根目录/templates/{templatePath}         (项目模板)
3. 插件目录/templates/{templatePath}            (插件默认 - 自动回退)
```

### 模板使用

1. **使用插件默认模板（推荐）**
```bash
# 直接使用 /deliver 命令，插件会自动使用默认模板
/deliver "实现用户登录功能"
```

2. **使用项目自定义模板**
```bash
# 在项目根目录创建模板目录
mkdir -p .claude/templates

# 复制并修改插件默认模板
cp {插件目录}/templates/requirements/agile/Story.md .claude/templates/

# 使用 /deliver 命令会自动优先使用项目模板
/deliver "实现用户登录功能"
```

### 模板覆盖策略

| 情况 | 行为 |
|------|------|
| 无任何本地模板 | ✅ 使用插件默认模板 |
| 有 .claude/templates/ | 优先使用，其次插件默认 |
| 有项目 templates/ | 其次使用，最后插件默认 |
| 模板文件缺失 | 自动回退到插件默认模板 |

---

## 持续学习循环

```markdown
┌─────────────────────────────────────────────────────────────┐
│                     持续学习循环                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐│
│   │  实施   │───▶│  验证   │───▶│  交付   │───▶│  学习   ││
│   └─────────┘    └─────────┘    └─────────┘    └─────────┘│
│       ▲                                          │         │
│       └──────────────────────────────────────────┘         │
│                    模式提取 → 知识沉淀 → 持续改进          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 模式提取
- 识别新发现的代码模式
- 记录最佳实践
- 创建可复用组件

### 知识沉淀
- 更新技能库
- 更新文档
- 更新模板

### 持续改进
- 收集反馈
- 优化流程
- 提升效率

---

## 质量门禁

### 阶段门禁

每个阶段完成后必须通过门禁才能进入下一阶段:

| 阶段 | 门禁标准 |
|------|----------|
| Discovery | 需求明确, 验收标准清晰 |
| Exploration | 代码库理解完整, 关键文件已标识 |
| Design | 架构方案明确, 实施蓝图详细 |
| Implementation | 测试通过, 覆盖率 ≥ 80% |
| Verification | 所有验证通过, 无阻塞性问题 |
| Delivery | 交付物完整, 价值已验证 |

### 质量标准

```markdown
## 代码质量
- 函数长度 ≤ 50 行
- 文件长度 ≤ 800 行
- 嵌套深度 ≤ 4 层
- 测试覆盖率 ≥ 80%

## 文档质量
- 所有公共 API 有文档
- 复杂逻辑有注释
- 变更日志完整

## 安全质量
- 无硬编码密钥
- 输入验证完整
- 错误处理安全
```

---

## 故障排查

### 常见问题

**Q: 阶段转换失败?**
A: 确保上一阶段门禁通过，检查前置条件

**Q: 测试覆盖率不足?**
A: 添加边界条件测试、错误场景测试

**Q: 代码审查不通过?**
A: 修复审查意见，重新提交审查

**Q: 构建失败?**
A: 检查语法错误、类型错误、依赖问题

---

## 最佳实践

### 1. 从小开始
- 先在简单功能上实践完整流程
- 逐步增加复杂度

### 2. 频繁验证
- 每个小步骤后验证
- 不要等到最后

### 3. 及时沟通
- 遇到问题及时沟通
- 不要假设

### 4. 记录决策
- 记录重要的架构决策
- 记录权衡的考虑

### 5. 持续改进
- 每次交付后总结
- 优化流程

---

**记住**: 端到端价值交付闭环不是一次性的活动，而是一个持续改进的循环。每一次交付都是学习的机会，每一次学习都让下一次交付更好。
